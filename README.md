# Go Stripe Payment API

  ![Go Version](https://img.shields.io/badge/Go-1.21-00ADD8?style=for-the-badge&logo=go)
  ![Stripe](https://img.shields.io/badge/Stripe-6772E5?style=for-the-badge&logo=stripe)
  ![PostgreSQL](https://img.shields.io/badge/PostgreSQL-4169E1?style=for-the-badge&logo=postgresql) 
  
A robust backend API built in Go that simulates a complete e-commerce flow. This project integrates a secure JWT User Authentication and Role-Based Access Control (RBAC) system with the Stripe API for payment processing. This project was developed as an in-depth study of software architecture, security, concurrency, and Go development best practices.

## ‚ú® Features

  * **User Authentication & Authorization:** Full registration and login flow using JWT.
  * **Role-Based Access Control (RBAC):** Secure 3-tier permission system (customer, admin, superadmin) using stacked middlewares.
  * **User Management:** superadmin-only endpoint to manage user roles.
  * **Full Product CRUD:** Admin-protected endpoints to Create, Read, Update, and Soft Delete (is_active) products.
  * **Order Creation:** customer-protected endpoint to create a new order with multiple items.
  * **Stripe Integration:** Generates `PaymentIntents` based on the total order value.
  * **Webhook Handler:** A secure endpoint to receive and process events from Stripe (e.g., `payment_intent.succeeded`), updating the order status in the database.
  * **Clean Architecture:** Utilizes dependency injection to decouple the application layers (handlers, repositories, database).

## üõ†Ô∏è Tech Stack

  * Language: Go
  * Payment Gateway: Stripe API
  * Database: PostgreSQL
  * Authentication: golang-jwt/jwt
  * HTTP Router: Gorilla Mux
  * Password Hashing: golang.org/x/crypto/bcrypt
  * Configuration: Environment variables with `godotenv`
  * Webhook Testing: Stripe CLI
  * API Testing: Postman

## üèõÔ∏è Database Schema

  The database is composed of four main tables designed to handle users, roles, products, and multi-item orders. The relationships are established through foreign keys linking `orders` to `users`, and `order_items` to both orders and products.

  ![Database Schema Diagram](docs/db_schema.png)

  <details>
  <summary>Click to view the DBML source code used to generate this diagram</summary>

  ```dbml
  // DBML code for dbdiagram.io

Table users {
  id bigserial [pk]
  nick varchar(255) [not null, unique]
  name varchar(255) [not null]
  email varchar(255) [not null, unique]
  password_hash varchar(255) [not null]
  created_at timestamptz [default: `now()`, not null]
  role varchar(50) [not null, default: 'customer']
}

Table products {
  id bigserial [pk]
  name varchar(255) [not null]
  nick varchar(50) [not null, unique]
  description text [not null, default: '']
  price_cents bigint [not null, note: 'CHECK(price_cents >= 50)']
  is_active boolean [not null, default: true]
  created_at timestamptz [default: `now()`]
}

Table orders {
  id bigserial [pk]
  user_id bigserial [not null]
  status varchar(50) [not null, default: 'pending']
  amount_cents bigint [not null]
  stripe_payment_intent_id varchar(255) [unique]
  created_at timestamptz [default: `now()`]
}

Table order_items {
  id bigserial [pk]
  order_id bigserial [not null]
  product_id bigserial [not null]
  quantity int [not null, note: 'CHECK(quantity > 0)']
  price_at_purchase_cents bigint [not null]
}

// Define relationships
Ref: orders.user_id > users.id
Ref: order_items.order_id > orders.id
Ref: order_items.product_id > products.id
```
</details>

## üöÄ Getting Started

Follow these steps to get a local copy up and running.

### Prerequisites

  * [Go](https://go.dev/doc/install) (version 1.21 or higher)
  * [PostgreSQL](https://www.postgresql.org/download/) installed locally
  * [Stripe CLI](https://stripe.com/docs/stripe-cli)
  * A [Stripe](https://stripe.com) account

### 1. Clone the Repository

  ```bash
  git clone https://github.com/RotigoZ/stripe-api-go.git
  cd stripe-api-go
  ```

### 2. Set up Environment Variables

  Create a `.env` file in the project root by copying the example file.
  ```bash
  cp .env.example .env
  ```
  Now, edit the `.env` file with your Stripe keys and database configuration:
  ```env
  # Your Stripe API keys (in test mode)
  SECRET_KEY="sk_test_..."
  PUBLISHABLE_KEY="pk_test_..."

  # Webhook signing secret generated by `stripe listen`
  STRIPE_WEBHOOK_SECRET="whsec_..." 

  # Database Configuration (Example for PostgreSQL)
  DATABASE_URL="postgres://your_user:your_password@localhost:5432/your_db_name?sslmode=disable"

  # Secret for signing JWT Tokens (generate a strong random string)
  JWT_SECRET="YOUR_VERY_STRONG_JWT_SECRET_KEY"
  ```

### 3. Install Dependencies
  ```bash
  go mod tidy
  ```

### 4. Prepare the Database
  Run the schema.sql script (containing the 4 tables above) to create the users, products, orders and order_items tables in your database.
  Bootstrap Super Admin: You must create your first superadmin manually.

  First, register a new user via the POST /users/register endpoint.

  Then, promote this user in your database:

  SQL

  UPDATE users SET role = 'superadmin' WHERE email = 'your-email@example.com';

### 5. Run the API
  ```bash
  go run ./cmd/api/main.go
  ```
  The server will be running on `http://localhost:3000`.

### 6. Start the Webhook Forwarding

  In a **second terminal**, start the Stripe CLI to forward events to your local API.
  ```bash
  stripe listen --forward-to localhost:3000/webhooks/stripe
  ```
  *(Remember to copy the `whsec_...` key that this command generates into your `.env` file and restart your API!)*

## üïπÔ∏è API Usage (Endpoints)

  All protected endpoints require an Authorization: Bearer <TOKEN> header, where <TOKEN> is the JWT received from the /login endpoint.

Authentication & User Management
POST /users/register [PUBLIC]

Registers a new user (default role: customer).

Body: { "name", "nick", "email", "password" }

POST /users/login [PUBLIC]

Authenticates a user and returns a JWT.

Body: { "email", "password" }

Success Response: { "token": "..." }

PUT /users/{id}/role [PROTECTED - SUPERADMIN]

Updates the role of a user.

Header: Authorization: Bearer <TOKEN>

Body: { "role": "admin" } or { "role": "customer" }

Product Management (Admin)
POST /products [PROTECTED - ADMIN]

Creates a new product. Requires admin or superadmin role.

Header: Authorization: Bearer <TOKEN>

Request Body (JSON):

JSON

{
  "name": "Product 1",
  "description": "This is product 1!",
  "price_cents": 5000
}
cURL Example:

Bash

curl -X POST http://localhost:3000/products \
-H "Content-Type: application/json" \
-H "Authorization: Bearer <TOKEN>" \
-d '{ "name": "Product 1", "description": "This is product 1!", "price_cents": 5000 }'
PUT /products/{id} [PROTECTED - ADMIN]

Updates an existing product.

DELETE /products/{id} [PROTECTED - ADMIN]

Soft Deletes a product (sets is_active = false).

PUT /products/{id}/activate [PROTECTED - ADMIN]

Re-activates a soft-deleted product (sets is_active = true).

Orders & Payments (Customer)
GET /products [PUBLIC]

Lists all active products.

GET /products/{id} [PUBLIC]

Gets a single active product.

POST /orders [PROTECTED - CUSTOMER]

Creates a new order and a Stripe PaymentIntent. Requires any authenticated user.

Header: Authorization: Bearer <TOKEN>

Request Body (JSON):

JSON

{
  "products": [
    { "product_id": 1, "quantity": 2 }
  ]
}
cURL Example:

Bash

curl -X POST http://localhost:3000/orders \
-H "Content-Type: application/json" \
-H "Authorization: Bearer <TOKEN>" \
-d '{ "products": [{ "product_id": 1, "quantity": 2 }] }'
Success Response:

JSON

{
  "clientSecret": "pi_..._secret_..."
}
POST /webhooks/stripe [PUBLIC - VERIFIED BY STRIPE]

Internal endpoint for Stripe to send events.

Listens for payment_intent.succeeded to update the order status to paid.

### Confirming the Payment (End-to-End Test)

  After creating an order, the API returns a `clientSecret`. To complete the payment flow and test the webhook, you must manually confirm this payment. This step simulates the action that a real frontend would perform using Stripe.js.

**1. Get the Payment Intent ID**

  From the response of the `POST /orders` request, copy the Payment Intent ID. It's the first part of the `clientSecret`, starting with `pi_...` and ending before _secret_.

**2. Confirm the Payment via Stripe's API**

  Using a tool like Postman or cURL, make a `POST` request directly to Stripe's API to confirm the payment.

  * **Endpoint:** `POST https://api.stripe.com/v1/payment_intents/YOUR_PAYMENT_INTENT_ID/confirm`
  * **Authorization:** Use your Stripe **Secret Key** (`sk_test_...`) as a Bearer Token.
  * **Body:** Set the body type to `x-www-form-urlencoded`. Add the following key-value pair: 
    * **Key:** `payment_method`
    * **Value:** `pm_card_visa`

  **cURL Example:**
  _Replace `YOUR_PAYMENT_INTENT_ID` and `YOUR_STRIPE_SECRET_KEY` with your actual values._
  ```bash
  curl -X POST https://api.stripe.com/v1/payment_intents/YOUR_PAYMENT_INTENT_ID/confirm \
    -u "YOUR_STRIPE_SECRET_KEY:" \
    -d payment_method=pm_card_visa
  ```

**3. Observe the Results**

After sending the confirmation request, you will see the full flow in action:
* **In your Stripe CLI terminal:** You will see the `payment_intent.succeeded` event being received from Stripe and forwarded to your API.
* **In your Go API terminal:** You will see the logs from your webhook handler processing the event.
* **In your database:** You can verify that the `status` of the corresponding order has been updated to `paid`.

## ‚úÖ Tests

This project does not yet have an automated test suite. Future work includes adding unit tests for the main business logic in the handlers and repositories to ensure code quality and prevent regressions.

## Future Improvement

* **User Authentication:** Implement JWT authentication for user-specific orders. (Done)
* **Frontend Application:** Build a client-side application to interact with the API.
* **Pagination:** Add pagination to the GET /products endpoint.
* **Unit Tests:** Add a full suite of unit and integration tests.
